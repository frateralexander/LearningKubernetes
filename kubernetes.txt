***
https://livro.descomplicandokubernetes.com.br/pt/
***

***

Control Plane      -> Controle do Kubernetes
                      > Gerenciamento geralmente pela AWS, GCP e afins, mas pode ser gerenciado pelo usuario se nuvem particular
     
Workers            -> Nós do Cluster
                      > Maquinas ou aplicações são rodadas nele

ETCD               -> Datastore. Armazena as especificações, status e configurações do cluster.
                      > Todos os dados armazenados dentro do etcd são manipulados apenas através da API
                      > Roda dentro do Control Plane

Scheduler          -> Selecionar o nó que irá hospedar um determinado pod (a menor unidade de um cluster k8s).
                      > É basicamente um agendador.
                      > Roda dentro do Control Plane

Controller Manager -> Garante que o cluster esteja no último estado definido no etcd.

Api Server         -> Este componente fornece uma API que utiliza JSON sobre HTTP para comunicação.
                      > Para isto é utilizado principalmente o utilitário kubectl
                      > As comunicações entre componentes são estabelecidas através de requisições REST

Kubelet            -> Desempenha o papel de um agente do k8s que é executado nos nós workers.
                      > Há um agente kubelet em cada nó worker gerenciando os pods direcionados pelo controller no cluster.
                      > Mantem os contêineres e os pods em funcionamento seguindo as instruções fornecidas pelo controlador do cluster.

Kube Proxy         -> Especie de proxy e um load balancer. 
                      > Responsável por efetuar roteamento de requisições para os pods corretos, também por cuida da parte de rede do nó 
                      
                   
***
Conceitos-chave do k8s
***

Container          -> 

Pod                -> É o menor objeto do k8s. Um pod pode possuir vários contêineres.
                      > O k8s não trabalha com os contêineres diretamente, mas organiza-os dentro de pods,
                        que são abstrações que dividem os mesmos recursos, como endereços, volumes, ciclos de CPU e memória.
                      > É escaláveil horizontalmente

Deployment         -> O Deployment, em conjunto com o ReplicaSet, garante que determinado número de réplicas de um pod esteja em execução nos nós workers do cluster.
                      >  É responsável por gerenciar o ciclo de vida das aplicações, onde características associadas a aplicação, tais como imagem, porta, volumes e variáveis de ambiente,
                         podem ser especificados em arquivos do tipo yaml ou json para posteriormente serem passados como parâmetro para o kubectl executar o deployment. 

ReplicaSets        -> É responsável por garantir a quantidade de pods em execução no nó (uma especie de controlador a serviço do Deployment)

Services           -> É a forma de expor a comunicação através de um ClusterIP, NodePort ou LoadBalancer para distribuir as requisições entre os diversos Pods daquele Deployment. 
                      > Funciona como um balanceador de carga entre os pods.

kubectl            -> Ferramenta de linha de comando oficial do Kubernetes
                      > Permite interagir com clusters, executar comandos, gerenciar recursos e instalar aplicações

Kind               -> O Kind (Kubernetes in Docker) é uma alternativa para executar o Kubernetes em ambiente local para testes e aprendizado (não recomendado em produção).


### Instalando e customizando o Kubectl

* Siga os passos abaixo:

 curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"

 sudo install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl

 kubectl version --client

### Instalando e customizando o Kind

Antes de instalar o kind é preciso instalar o docker, execute os comandos abaixo:

 curl -fsSL https://get.docker.com -o get-docker.sh

 sudo sh get-docker.sh

 sudo usermod -aG docker $USER

Agora siga com a instalação do kind

 curl -Lo ./kind https://kind.sigs.k8s.io/dl/v0.20.0/kind-linux-amd64

 sudo install -o root -g root -m 0755 kind /usr/local/bin/kind


# # # # # # # # #
# Testes Dia 1  #
# # # # # # # # # 

### Criando cluster no kind (Esse teste cria um cluster com apenas um nó, que fica sendo o control-plane e os workers ao mesmo tempo)

* Crie um novo cluster    

 kind create cluster

* Confirme a criação com o comando abaixo

 kubectl cluster-info --context kind-kind

* Verificando nós

  kubectl get nodes 

* Crie um novo com nome especifico

 kind create cluster --name leleu-coceira

* Liste os cluster's criados

  kind get clusters

* Apague os clusters criados

  kind delete clusters $(kind get cluster)

### Criando um cluster com multiplos múltiplos nós locais com o Kind

* Crie um arquivo de configuração yaml (o comando abaixo cuidará disso)

 cat << EOF > $HOME/leleu-3nodes.yaml
 kind: Cluster
 apiVersion: kind.x-k8s.io/v1alpha4
 nodes:
   - role: control-plane
   - role: worker
   - role: worker
 EOF

* Agora vamos criar um cluster chamado kind-multinodes utilizando as especificações definidas no arquivo kind-3nodes.yaml.

 kind create cluster --name leleu-coceira --config leleu-3nodes.yaml

### Contato Inicial

* Verificando os namespaces e pods

 kubectl get namespaces

* listando os pods do namespace kube-system (um dos namespaces)

 kubectl get pods -n kube-system

{{Nota:
        O kube-system isola os recursos internos do cluster das suas cargas de trabalho (aplicações). Sendo reservado para os recursos
        do próprio sistema Kubernetes (o core do cluster)
}}

* Listando pods de todos os namespaces

 kubectl get pods -A

ou

 kubectl get pods -A -o wide

* Obtendo detalhes de um nó

 kubectl describe node [nome-do-nó] 

{{Nota: 
        O nome dos nós pode ser obtido com o comando `kubectl get nodes`
}}

### Executando nosso primeiro pod no k8s

* Inicie o pod

 kubectl run nginx --image nginx

* Confira se foi criado

 kubectl get pods

* Remova o pod

 kubectl delete pod nginx

### Executando nosso primeiro pod no k8s utilizando um arquivo manifesto

* Criando pod através da utilizaçâo de uma arquivo manifesto.

Primeiro, criamos um template:

  kubectl run my-nginx --image nginx --dry-run=client -o yaml > pod-template.yaml

Depois, com o template em mãos, crie o novo pod:

 kubectl apply -f pod-template.yaml

{{Nota:
        Arquivo manifesto é um arquivo em formato YAML onde você passa todas as definições do seu objeto.
}}

### Expondo o pod e criando um Service

* Apaque o pod anterior e recrie com o comando

 kubectl run meu-nginx --image nginx --port 80 --dry-run=client -o yaml > pod-template.yaml

 kubectl create -f pod-template.yaml

* Liste os pods

 kubectl get pods

* Exponha o pod

 kubectl expose pod meu-nginx

* Liste os serviços

 kubectl get pods,services

### Fazendo com Deployment

* Primeiro devemos apagar todo o ambiente anterior

 kind delete cluster --name meu-nginx

 kubectl delete all --all-namespaces

 pkill -f "kubectl port-forward"

* Crie o arquivo yaml (leleu-coceira.yaml)

	kind: Cluster
	apiVersion: kind.x-k8s.io/v1alpha4
	nodes:
	- role: control-plane
	  extraPortMappings:
	  - containerPort: 30080
	    hostPort: 30080
	    listenAddress: 127.0.0.1
	    protocol: TCP 

* Rode o comando para criar o novo cluster

 kind create cluster --name leleu-coceira --config leleu-coceira.yaml 

* Crie o arquivo para deploy (nginx-deploy.yaml)

	apiVersion: apps/v1
	kind: Deployment
	metadata:
	  name: nginx
	spec:
	  replicas: 10
	  selector:
	    matchLabels:
	      app: nginx
	  template:
	    metadata:
	      labels:
	        app: nginx
	    spec:
	      containers:
	      - name: nginx
	        image: nginx:alpine
	        ports:
	        - containerPort: 80
	---
	apiVersion: v1
	kind: Service
	metadata:
	  name: nginx
	spec:
	  type: NodePort
	  ports:
	  - port: 80
	    targetPort: 80
	    nodePort: 30080
	  selector:
	    app: nginx


# # # # # # # # #
# Testes Dia 2  #
# # # # # # # # #

.:: Objetivos ::.

1. Estudar o menor objeto do kubernetes: o POD.
   1.1. Criação
   1.2. Pod com multicontainers
   1.3. Pod com volumes
   1.4. Limitação ao consumo de recursos: CPU, memória, etc.

.:: Conceitos ::.

Pod é a menor unidade dentro de um cluster.
Pod é como um caixa, podendo ter um ou mais containers.
Esses containers compartilham os mesmos recursos do Pod, como por exemplo, o IP, o namespace, o volume, etc.
Quando falamos de Pod, estamos falando de um ou mais containers que compartilham os mesmos recursos, ponto.

	+--------------------------------------------------------------+
	|          POD (A "Caixa" - Menor Unidade do Cluster)          |
	|                                                              |
	|  +--  Recursos Compartilhados (Namespace, IP: 10.0.0.1) --+  |
	|  |                                                        |  |
	|  |    +-------------------+       +-------------------+   |  |
	|  |    |                   |       |                   |   |  |
	|  +--->|    Container A    |  < >  |    Container B    | <-+  |
	|       |                   |       |                   |      |
	|       +---------+---------+       +---------+---------+      |
	|                 |                           |                |
	|                 |                           |                |
	|                 v                           v                |
	|       +-------------------------------------------+          |
	|       |           VOLUME (Disco/Dados)            |          |
	|       +-------------------------------------------+          |
	|                                                              |
	+--------------------------------------------------------------+

### Criando um pod via linha de comando

Primeiro vamos criar um cluster

 king create cluster

Agora vamos criar nosso pod

 kubectl run leleu-coceira --image=nginx --port=80

Visualize o pod

 kubectl get pods

ou de forma um pouco mais detalhada

 kubectl get pods -o wide

Trabalheremos com namespaces outros dia. Por enquanto, vamos focar em Pods e apenas temos que saber que por padrão,
o Kubernetes irá criar todos os objetos dentro da namespace default se não especificarmos outra.

Se quisermos já ver os pods que temos dentro das namespaces podemos usar os seguintes comandos

 kubectl get pods --all-namespaces

 kubectl get pods -A

O pod que acabamos de criar vai aparecer no namespace "default".

Se quisermos ver apenas os pods existentes dentro de um namespace podemos utilizar o comando abaixo

 kubect get pods -n <namespace>

E caso queiramos detalhes sobre o eles basta jogarmos a saida para o yaml ou para json

 kubectl get pods -n <namespace> -o yaml

 kubectl get pods -n <namespace> -o json

Outra forma de vizualirmos detalhes acerca do pod

 kubectl describe pods <nome do pod>

Removendo o pod

 kubectl delete pod <nome do pod>

### Criando um Pod através de um arquivo YAML

Criaremos agora um pod por meio de um arquivo yaml. 

 cat << EOF > pod_leleu-coceira.yaml
 # Versão da api do kubernetes
 apiVersion: v1
 # Tipo de objeto a se criar
 kind: Pod
 # Metadados do Pod
 metadata:
   # Nome do Pod que criaremos
   name: leleu-coceira
   # Labels do Pod
   labels:
     # Label run com o valor leleu-coceira
     run: leleu-coceira
 # Especificação do Pod
 spec:
   # Containers que estarão dentro do Pod
   containers:
   # O Hifen abaixo indica o inicio da lista de containers
   - name: leleu-coceira
     # Imagem que o Pod utilizará
     image: nginx
     # Portas de comunicação expostas pelo container
     ports:
     # Hifen para lista de portas e espaço após os dois pontos
     - containerPort: 80
 EOF

Agora utilize o get para ver o Pod criado

 kubectl get pods

O comando apply é um comando aplica o arquivo YAML no cluster, ou seja, ele cria o objeto que está descrito no arquivo YAML no cluster.
Caso o objeto já exista, ele irá atualizá-lo com as informações que estão no arquivo YAML.

Vamos agora visualizar os logs de nosso Pod

 kubectl logs <nome do pod>

Também é possível ver os logs em tempo real

 kubectl logs -f <nome do pod> 

Agora vamos apagar nosso Pod

 kubectl delete pod <nome do pod>

### Criando um Pod com multiplos containers (ainda utilizando arquivo YAML)

Criaremos agora o yaml que permitira levantarmos um pod com dois containers internos.

 cat << EOF >> pod_multi_contaners-chihuahua.yaml
 # Versão da API do kubernetes
 apiVersion: v1
 # Tipo de objeto a se criar
 kind: Pod
 # Metadados do Pod
 metadata:
   # Nome do Pod  
   name: chihuahua
     # Labels do pod
   labels:
     # label run com o valor chihuahua 
     run: chihuahua
 # Especificação do pod
 spec:
   # Criando os containers
   containers:
   # Nome do container
   - name: leleu-coceira
     # Imagem do container
     image: nginx
     # Portas expostas pelo container
     ports:
     - containerPort: 80
   # Nome do container    
   - name: valdete-pedrada
     # Imagem do container
     image: alpine
     args:
     - sleep
     - "1800"
 EOF

Agora criemos o Pod

 kubectl apply -f pod_multi_contaners-chihuahua.yaml

Vamos visualizar o pod

 kubectl get pods chihuahua

 kubectl describe pods chihuhua

### Utilizando os comandos attach e exec

O attach é como se estivéssemos conectando diretamente em uma console de uma máquina virtual, não estamos criando nenhum processo dentro do container, apenas nos conectando a ele.

 kubectl attach chihuahua -c leleu-coceira

Por esse motivo se tentarmos utilizar o attach para conectar no container que está rodando o Nginx, nós iremos conectar ao container e ficaremos presos ao processo do Nginx que está
em execução em primeiro plano, e não conseguiremos executar nenhum outro comando.

 kubectl attach chihuhua -c valdete-pedrada

Só vamos usar o attach para se conectar a um container que está rodando dentro de um Pod, e não para executar comandos dentro do container.

No entando, para rodar comandos dentro do container, devemos utilizar o comando exec

 kubectl exec chihuahua -c leleu-coceira -- ls

 kubectl exec chihuahua -c valdete-pedrada -- ls

Para conectar em um container que está rodando dentro de um Pod podemos passar o parâmetro -it para o comando exec.

 kubectl exec chihuahua -c valdade-pedrada -it -- sh 

Para sair basta digiratar CTRLC+D

Agora, remova o pod

 kubectl delete pod <nome do pod>

### Criando um container com limites de memória e CPU

Vamos trabalhar agora na limitação de recursos. Para isso vamos criar nosso proximo arquivo YAML

 cat << EOF > pod-limitado.yaml
 # Versão da API
 apiVersion: v1
 # Tipo de objeto que estamos criando (Letra maiúscula importa!)
 kind: Pod
 # Metadados do pod
 metadata:
   # Nome do pod
   name: chihuahua
   # Labels do pod
   labels:
     # Label run com valor chihuahua 
     run: chihuahua
 # Especificação do pod    
 spec:
   # Containers dentro do pod (PLURAL: containers)
   containers:
   # Nome do container
   - name: leleu-coceira
     # Imagem que esta utilizando
     image: nginx
     # Portas expostas pelo container
     ports:
     # Porta 80 exposta
     - containerPort: 80
     # Controle de recursos utilizados
     resources:
       # Especificação de limites (Teto máximo)
       limits:
         # Memoria alocada para o container
         memory: "128Mi" 
         # Cpu alocada para o container (0.5 = meio núcleo)
         cpu: "0.5"
       # Recursos garantidos ao container (PLURAL: requests)
       requests:
         # Memoria garantida pelo container
         memory: "64Mi"
         # Cpu garantida pelo container
         cpu:  "0.3"
 EOF

Agora criamos o pod

 kubectl apply -f pod-limitado.yaml

ou

 kubectl create -f pod-limitado.yaml

Utilizamos O campo resources é para definir os recursos que utilizados pelo container.

O campo limits é usado para definir os limites máximos de recursos que o container pode utilizar e o campo requests é usado para definir os recursos garantidos ao container.

{{Nota: 
        Observe que o kubernetes trabalha com valor Mi e Gi (Mebibyte e Gibibyte)

 +---------+----------+--------------------+---------------+
 | Notação | Nome     | Valor Real (Bytes) | Diferença     |
 +---------+----------+--------------------+---------------+
 | 1 M     | Megabyte | 1.000.000          | Padrão (Base) | 
 +---------+----------+--------------------+---------------+
 | 1 Mi    | Mebibyte | 1.048.576          | ~4.8% maior   |
 +---------+----------+--------------------+---------------+
 | 1 G     | Gigabyte | 1.000.000.000      | Padrão (Base) |
 +---------+----------+--------------------+---------------+
 | 1 Gi    | Gibibyte | 1.073.741.824      | ~7.3% maior   |
 +---------+----------+--------------------+---------------+

}}

Se analisarmos nosso pod como describe, veremos a saida indicando uso de cpu em 500 (que significa 50% do uso de uma cpu)

 [...]
 Limits:
      cpu:     500m
      memory:  128Mi
    Requests:
      cpu:        300m
      memory:     64Mi
 [...]

Vamos agora fazer um novo teste, vamos criar um pod ubuntu.

 cat <<EOF > pod-ubuntu-limitado.yaml
 apiVersion: v1
 kind: Pod
 metadata:
   name: ubuntu
 spec:
   containers:
   - name: ubuntu
     image: ubuntu
     args:
       - sleep
       - infinity
     resources:
       limits:
         memory: "128Mi"
         cpu: "0.5"
       requests:
         memory: "64Mi"
         cpu: "0.3"
 EOF

Criamos o pod

 kubectl create pod -f pod-ubuntu-limitado.yaml

Entramos no container

 kubectl exec ubuntu -it -- bash

Instale o stress

 apt update
 apt install -y stress

Rode o comando stress consumindo 100 de memoria

 stress --vm 1 --vm-bytes 100M

Agora tente rodar consumindo 200

 stress --vm 1 --vm-bytes 200M

Observe que vai retornar um erro...

 root@ubuntu:/# stress --vm 1 --vm-bytes 200M
 stress: info: [201] dispatching hogs: 0 cpu, 0 io, 1 vm, 0 hdd
 stress: FAIL: [201] (425) <-- worker 202 got signal 9
 stress: WARN: [201] (427) now reaping child worker processes
 stress: FAIL: [201] (461) failed run completed in 0s

### Adicionando um volume EmptyDir no Pod

Não vamos nos aprofundar muito agora na questão de volumes, mas vamos começar a olhar para eles.

Iniciaremos com a criação de um Pod com volume EmptyDir. Esse tipo volume é criado no momento em que o Pod é criado, e ele é destruído quando o Pod é destruído,
ou seja, ele é um volume temporário.

Vamos criar o arquivo para levantar o pod

 cat << EOF > pod-emptydir.yaml
 apiVersion: v1
 kind: Pod
 metadata:
   name: dir-testing
 spec:
   containers:
   - name: emptydir
     image: ubuntu
     args:
     - sleep
     - infinity
     # Lista de volumes
     volumeMounts:
     - name: emptyvol1
       mountPath: /emptyvol1
   volumes:
   - name: emptyvol1
     emptyDir:
       sizeLimit: 256Mi
 EOF

agora crie o volume

 kubectl create -f pod-emptydir.yaml

Acesse o Pod

 kubectl exec dir-testing -it -- bash

Verifique a montagem 

 root@dir-testing:/# mount | grep emptyvol1
 /dev/sdb2 on /emptyvol1 type ext4 (rw,relatime,errors=remount-ro)

 root@dir-testing:/# df -h
 Filesystem      Size  Used Avail Use% Mounted on
 overlay         219G   60G  148G  29% /
 tmpfs            64M     0   64M   0% /dev
 /dev/sdb2       219G   60G  148G  29% /emptyvol1
 shm              64M     0   64M   0% /dev/shm
 tmpfs            32G   12K   32G   1% /run/secrets/kubernetes.io/serviceaccount
 tmpfs            16G     0   16G   0% /proc/asound
 tmpfs            16G     0   16G   0% /proc/acpi
 tmpfs            16G     0   16G   0% /proc/scsi
 tmpfs            16G     0   16G   0% /sys/firmware

Por fim, crie algo dentro do volume

 touch /emptyvol1/testing

Verifique a criação

 root@dir-testing:/# ls /emptyvol1/
 testing



